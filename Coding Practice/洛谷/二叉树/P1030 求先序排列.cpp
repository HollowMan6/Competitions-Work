// P1030 求先序排列
// 给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，长度≤8）。

// 输入输出格式
// 输入格式：
// 22行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。

// 输出格式：
// 11行，表示一棵二叉树的先序。

// 输入输出样例
// 输入样例#1： 
// BADC
// BDCA

// 输出样例#1： 
// ABCD

用的是DFS，其实就是递归；
我说一下这题的主要的方法（要点），
1.后序遍历中，最后一个节点一定是根节点（对于每一颗子树也成立）；
2.既然这题要求先序遍历，那么我们只需一次输出访问的父节点即可；
这样的话，我们只要递归将一棵大树分成两颗子树，让后找他们的父节点，不断递归输出；
3.那么难点就在这了，如何通过一个中序和后序遍历中找出两段子树的后序遍历序列（后序，因为只有后序我们才方便找到父节点）呢？
自己可以拿几个样例做一做，耐性点就会发现它的套路，我这里简单说一下：
在中序遍历中找到当前父节点后，我们可以分别求出他的左子树节点数和右子树节点数，因为中序遍历访问的顺序是左子树，父节点，右子树，所以可以直接计算出；
然后，由于我们对结点的访问一定是先访问一颗子树，在访问另一颗，所以在我们的原后序遍历串右边界中减掉右子树节点个数再减一即为新的左子树右边界，在原后序遍历串左边界加上左子树节点个数即为新的右子树左边界；
当然右子树右边界和左子树左边界这个非常好确定。

#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
char s1[10];
char s2[10];
int len;
inline int find(char ch)
{
    for(int i=0;i<len;i++)
    {
        if(s1[i]==ch) return i;
    }
}
void dfs(int l1,int r1,int l2,int r2)
{
    int m=find(s2[r2]);
    cout<<s2[r2];
    if(m>l1) /*具有左子树*/dfs(l1,m-1,l2,r2-r1+m-1);//r1-m为右子树结点数 
    if(m<r1) /*具有右子树*/dfs(m+1,r1,l2+m-l1,r2-1);//m-l1为左子树节点数
}
int main()
{
    cin>>s1;
    cin>>s2;
    len=strlen(s1);
    dfs(0,len-1,0,len-1);
}